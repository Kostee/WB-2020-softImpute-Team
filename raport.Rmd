---
title: "softImpute"
author: "Jakub Kosterna, Dawid Przybyliński, Hanna Zdulska"
date: "25 marca 2020"
output:
  html_document:
    df_print: paged
    toc: true
    toc_float: true
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Wprowadzenie

## Geneza i zawartość

SoftImpute to nieduży i przydatny pakiet do uzupełniania macierzy, stworzony przez Trevor Hastiego (Stanford, autor wielu książek o statystce). Wykorzystuje do tego **nuclear norm regularization**, znanej także jako **trace norm regularization** (pl: *regularyzacja norm śladowych*). Biblioteka implementuje: 

  * funkcję *softImpute()* z dwoma przydatnymi algorytmami:

    1. Iteracyjne obliczenie soft-thresholded SVD z wypełnionej macierzy (opcja *type="svd"*)

    2. Uzupełnianie braków ramki szacunkami korzystając z alternating ridge regression(zwane popularniej w Europie Tikhonov regularization) (opcja *type="als"*)
    
  * *biscale()* - zoptymalizowane scale() działające również na niekompletnej macierzy, działające też szybko na bardzo dużych macierzach
  
  * dwie nowe klasy dla macierzy: *SparseplusLowRank* i *Incomplete*
  
## Zalety i wady

Pakiet z założenia służy do uzupełniania macierzy, wymaga on nas konwersji z data.frame na klasę matrix. Operuje tylko na macierzach, co jest równocześnie zaletą - potrzebuje tylko pakiet Matrix:
```{r, warning = FALSE}
require(deepdep)
plot_dependencies(deepdep("Amelia", depth = 2))
plot_dependencies(deepdep("missMDA", depth = 2))
plot_dependencies(deepdep("missForest", depth = 2))
plot_dependencies(deepdep("VIM", depth = 2))
plot_dependencies(deepdep("mice", depth = 2))
plot_dependencies(deepdep("softImpute", depth = 2))
```


Zaletą pakietu jest fakt, że może obsługiwać zarówno małe, jak i bardzo duże macierze w relatywnie krótkim czasie, dzięki użyciu klasy Incomplete. Dla przykładu `softImpute` bez problemu dopasuje macierz rzędu 100 do danych Netflixa (480,189 użytkowników x 17,770 filmów co daje około 8.6 * 10^9 obserwacji, przy czym średnio jeden użytkownik ocenia tylko 200 filmów, co daje tylko 1.2% obserwacji ~10^8) w 3.3h

# Jak działa algorytm? 

## Soft-thresholded SVD

Niech $X$  będzie dużą $m\times n$ macierzą z wiloma brakującymi wartościami. Niech $\Omega$ zawiera pary indeksów $(i,j)$ gdzie $X$ był zaobserwowany, i niech $P_\Omega(X)$ oznacza macierz z wartościami jak w $X$ w punktach z $\Omega$, a w pozostałych ma wartości 0. Zatem jeśli $X$ ma brakujące wartości w $\Omega^\perp$, $P_\Omega(X)$ by oznaczyło NA jako 0. 
 
Rozważmy wyrażenie
$$\min_M\frac12\|P_\Omega(X)-M\|^2_F+\lambda\|M\|_*,$$
gdzie $\|M\|_*$ to suma wartości singularnych macierzy $M$ (nucelar norm, trace norm), natomiast $\lambda$ jest parametrem.

Niech $\widehat M$ będzie przybliżeniem rozwiązania problemu:
$$Z=P_\Omega(X)+P_{\Omega^\perp}(\widehat M).$$

$${\widehat M}=S_\lambda(Z)$$ 

Operator $S_\lambda(Z)$ dla macierzy $Z$ wykonuje następujące instrukcje:

1. Znajduje rozkład SVD dla $Z=UDV$, oraz $d_i$ - wartości singularne $Z$.
2. Zaszumia wartości singularne: $d_i^*= (d_i-\lambda)_+$.
3. Tworzy nową macierz $Z$: $S_\lambda(Z)=UD^*V$.
Dla dostaecznie dużych wartości $\lambda$, $D^*$ będzie miało zmniejszony rząd, więc również i $UD^*V$.

Stąd tworząc kolejne macierze ${\widehat M}$, dostajemy algorytm iteracyjny. 

## Rozkład SVD

Każdą macierz A można przedstawić jako:

$$ A = UDV $$
gdzie: 

$U, V$ - macierze ortogolnalne

$D$ - macierz diagonalna złożona z wartości singularnych $A$ 


# Działanie

## Odczyt

```{r odczyt, message = FALSE, warning = FALSE}
# install.packages("softImpute") # if not installed
library(softImpute)
```

## Przykłady

Wpierw w celu obycia ze składnią przetestujmy wpierw naszą podstawową funkcję na losowej macierzy 5 x 6 z wartościami z rozkładu normalnego i usuńmy z niej losowe 7 wartości.

```{r przyklad1_1}
set.seed(17)

X = matrix(rnorm(30), 5, 6)
X_del = X
X_del[sample(1:30, 7, replace = FALSE)] = NA
X_del
```

Utworzymy zmienną *fits* generującą dopasowanie w zależności od macierzy z usuniętymi wartościami, a następnie wypełnimy ją z pomocą funkcji *complete()*.

```{r przyklad1_2}
fits <- softImpute(X_del, trace = TRUE, type="svd")
completed <- complete(X_del, fits)
```

Zobaczmy macierz wejściową, wypełnioną, ich różnicę i miarę rmse.

```{r przyklad1_3}
X
completed
X - completed
# install.packages("Metrics") # if not installed
library(Metrics)
rmse(X, completed)
```

W kolejnych krokach będziemy rozpatrywać macierz wygenerowaną w bardziej złożony sposób zawierającą już pewne nie-zupełnie-losowe własności matematyczne. Wpierw przygotujmy ją i usuńmy 30% wartości.

```{r przyklad2_1}
set.seed(101)
n <- 200
p <- 100
J <- 50
np <- n * p
missfrac <- 0.3

x <- matrix(rnorm(n*J), n, J) %*% matrix(rnorm(J*p), J, p) + matrix(rnorm(np), n, p) / 5
sample(x, 20)

ix <- seq(np)
imiss <- sample(ix, np*missfrac, replace=FALSE)
xna <- x
xna[imiss] = NA
```

Metoda "klasyczna"

```{r przyklad2_2}
### uses regular matrix method for matrices with NAs
fit1 <- softImpute(xna, rank = 50, lambda = 30)
```

```{r przyklad2_3}
### uses sparse matrix method for matrices of class "Incomplete"
xnaC <- as(xna, "Incomplete")
fit2 <- softImpute(xnaC, rank=50, lambda=30)
```

```{r przyklad2_4}
### uses "svd" algorithm
fit3 <- softImpute(xnaC, rank=50, lambda=30, type="svd")
ximp <- complete(xna,fit1)
```

```{r przyklad2_5}
### first scale xna
xnas <- biScale(xna)
fit4 <- softImpute(xnas,rank=50,lambda=10)
ximp <- complete(xna,fit4)
impute(fit4, i = c(1, 3, 7), j = c(2, 5, 10))
impute(fit4, i = c(1, 3, 7), j = c(2, 5, 10), unscale=FALSE) #ignore scaling and centering
```

# Bibliografia - poczytaj wiecej
 * [Mazumder et al (2010)](http://web.stanford.edu/~hastie/Papers/mazumder10a.pdf)
 * [Hastie et al (2014)](http://arxiv.org/abs/1410.2596)