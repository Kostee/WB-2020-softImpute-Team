---
title: "softImpute"
author: "Jakub Kosterna, Dawid Przybyliński, Hanna Zdulska"
date: "25 marca 2020"
output:
  html_document:
    df_print: paged
    toc: true
    toc_float: true
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Wprowadzenie

## Geneza i zawartość

SoftImpute to nieduży i przydatny pakiet do uzupełniania macierzy, stworzoną przez Trevor Hastiego(Stanford, autor wielu książek o statystce). Wykorzystuje do tego **nuclear norm regularization**, znanej także jako **trace norm regularization** (pl: *regularyzacja norm śladowych*). Biblioteka implementuje: 

  * funkcję *softImpute()* z dwoma przydatnymi algorytmami:

    1. Iteracyjne obliczenie soft-thresholded SVD z wypełnionej macierzy (opcja *type="svd"*)

    2. Uzupełnianie braków ramki szacunkami korzystając z alternating ridge regression(zwane popularniej w Europie Tikhonov regularization) (opcja *type="als"*)
    
  * biscale() - zoptymalizowane scale() działające również na niekompletnej macierzy, działające też szybko na bardzo dużych macierzach
  
  * dwie nowe klasy dla macierzy: SparseplusLowRank i Incomplete
  
## Zalety i wady

Pakiet z założenia służy do uzupełniania macierzy, wymaga on nas konwersji z data.frame na klasę matrix. Operuje tylko na macierzach, co jest równocześnie zaletą - potrzebuje tylko pakiet Matrix:
```{r}
require(deepdep)
plot_dependencies(deepdep("Amelia", depth = 2))
plot_dependencies(deepdep("missMDA", depth = 2))
plot_dependencies(deepdep("missForest", depth = 2))
plot_dependencies(deepdep("VIM", depth = 2))
plot_dependencies(deepdep("mice", depth = 2))
plot_dependencies(deepdep("softImpute", depth = 2))
```


Zaletą pakietu jest fakt, że może obsługiwać zarówno małe, jak i bardzo duże macierze w relatywnie krótkim czasie, dzięki użyciu klasy Incomplete. Dla przykładu `softImpute` bez problemu dopasuje macierz rzędu 100 do danych Netflixa (480,189 użytkowników x 17,770 filmów co daje około 8.6 * 10^9 obserwacji, przy czym średnio jeden użytkownik ocenia tylko 200 filmów, co daje tylko 1.2% obserwacji ~10^8) w 3.3h

# Jak działa algorytm? 

## Soft-thresholded SVD

Niech $X$  będzie dużą $m\times n$ macierzą z wiloma brakującymi wartościami. Niech $\Omega$ zawiera pary indeksów $(i,j)$ gdzie $X$ był zaobserwowany, i niech $P_\Omega(X)$ oznacza macierz z wartościami jak w $X$ w punktach z $\Omega$, a w pozostałych ma wartości 0. Zatem jeśli $X$ ma brakujące wartości w $\Omega^\perp$, $P_\Omega(X)$ by oznaczyło NA jako 0. 
 
Rozważmy wyrażenie
$$\min_M\frac12\|P_\Omega(X)-M\|^2_F+\lambda\|M\|_*,$$
gdzie $\|M\|_*$ to suma wartości singularnych macierzy $M$ (nucelar norm, trace norm), natomiast $\lambda$ jest parametrem.

Niech $\widehat M$ będzie przybliżeniem rozwiązania problemu:
$$Z=P_\Omega(X)+P_{\Omega^\perp}(\widehat M).$$

$${\widehat M}=S_\lambda(Z)$$ 

Operator $S_\lambda(Z)$ dla macierzy $Z$ wykonuje następujące instrukcje:

1. Znajduje rozkład SVD dla $Z=UDV$, oraz $d_i$ - wartości singularne $Z$.
2. Zaszumia wartości singularne: $d_i^*= (d_i-\lambda)_+$.
3. Tworzy nową macierz $Z$: $S_\lambda(Z)=UD^*V$.
Dla dostaecznie dużych wartości $\lambda$, $D^*$ będzie miało zmniejszony rząd, więc również i $UD^*V$.

Stąd tworząc kolejne macierze ${\widehat M}$, dostajemy algorytm iteracyjny. 

## Rozkład SVD

Każdą macierz A można przedstawić jako:

$$ A = UDV $$
gdzie: 

$U, V$ - macierze ortogolnalne

$D$ - macierz diagonalna złożona z wartości singularnych $A$ 


# Działanie

## Odczyt

```{r odczyt, message = FALSE, warning = FALSE}
# install.packages("softImpute") # if not installed
library(softImpute)
```

## Przykład

Wygenerujmy losową macierz 5 x 6 i usuńmy losowe 7 wartości.

```{r przyklad1_1}
set.seed(123)

X = matrix(rnorm(30), 5, 6)
X
X_del = X
X_del[sample(1:30, 7, replace = FALSE)] = NA
X_del
```

Zobaczmy wynik działania *soft_impute()*. W tym celu utworzymy zmienną *fits* generującą dopasowanie w zależności od macierzy z usuniętymi wartościami, a następnie wypełnimy ją z pomocą funkcji *complete()*.

```{r przyklad1_2}
fits = softImpute(X_del, trace = TRUE, type="svd")
complete(X_del, fits)
```

Jak widać funkcja poradziła sobie całkiem dobrze w przypadku losowo wygenerowanych wartości z rozkładu normalnego.

# Bibliografia - poczytaj wiecej
 * [Mazumder et al (2010)](http://web.stanford.edu/~hastie/Papers/mazumder10a.pdf)
 * [Hastie et al (2014)](http://arxiv.org/abs/1410.2596)