---
title: "softImpute"
author: "Jakub Kosterna, Dawid Przybyliński, Hanna Zdulska"
date: "25 marca 2020"
output:
  html_document:
    df_print: paged
    toc: true
    toc_float: true
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Wprowadzenie

## Geneza i zawartość

SoftImpute to nieduży i przydatny pakiet do uzupełniania macierzy, stworzoną przez Trevor Hastiego(Stanford, autor wielu książek o statystce). Wykorzystuje do tego **nuclear norm regularization**, znanej także jako **trace norm regularization** (pl: *regularyzacja norm śladowych*). Biblioteka implementuje: 

  * funkcję *softImpute()* z dwoma przydatnymi algorytmami:

    1. Iteracyjne obliczenie soft-thresholded SVD z wypełnionej macierzy (opcja *type="svd"*)

    2. Uzupełnianie braków ramki szacunkami korzystając z alternating ridge regression(zwane popularniej w Europie Tikhonov regularization) (opcja *type="als"*)
    
  * biscale() - zoptymalizowane scale() działające również na niekompletnej macierzy, działające też szybko na bardzo dużych macierzach
  
  * dwie nowe klasy dla macierzy: SparseplusLowRank i Incomplete
  
## Zalety i wady

Pakiet z założenia służy do uzupełniania macierzy, wymaga on nas konwersji z data.frame na klasę matrix. Operuje tylko na macierzach, co jest równocześnie zaletą - potrzebuje tylko pakiet Matrix:
```{r}
require(deepdep)
plot_dependencies(deepdep("Amelia", depth = 2))
plot_dependencies(deepdep("missMDA", depth = 2))
plot_dependencies(deepdep("missForest", depth = 2))
plot_dependencies(deepdep("VIM", depth = 2))
plot_dependencies(deepdep("mice", depth = 2))
plot_dependencies(deepdep("softImpute", depth = 2))
```


Zaletą pakietu jest fakt, że może obsługiwać zarówno małe, jak i bardzo duże macierze w relatywnie krótkim czasie, dzięki użyciu klasy Incomplete. Dla przykładu `softImpute` bez problemu dopasuje macierz rzędu 100 do danych Netflixa (480,189 użytkowników x 17,770 filmów co daje około 8.6 * 10^9 obserwacji, przy czym średnio jeden użytkownik ocenia tylko 200 filmów, co daje tylko 1.2% obserwacji ~10^8) w 3.3h

# Teoria

No dobra, ale czym właściwie była ta *trace norm*?

Jest to suma wartości bezwzględnych wartości własnych macierzy,

$||A||_{1} = trace((\sqrt{(X^{*}X)}))$

# Działanie

## Odczyt

```{r odczyt, message = FALSE, warning = FALSE}
# install.packages("softImpute") # if not installed
library(softImpute)
```

## Przykład

Wygenerujmy losową macierz 5 x 6 i usuńmy losowe 7 wartości.

```{r przyklad1_1}
set.seed(123)

X = matrix(rnorm(30), 5, 6)
X
X_del = X
X_del[sample(1:30, 7, replace = FALSE)] = NA
X_del
```

Zobaczmy wynik działania *soft_impute()*. W tym celu utworzymy zmienną *fits* generującą dopasowanie w zależności od macierzy z usuniętymi wartościami, a następnie wypełnimy ją z pomocą funkcji *complete()*.

```{r przyklad1_2}
fits = softImpute(X_del, trace = TRUE, type="svd")
complete(X_del, fits)
```

Jak widać funkcja poradziła sobie całkiem dobrze w przypadku losowo wygenerowanych wartości z rozkładu normalnego.

# Bibliografia - poczytaj wiecej
 * [Mazumder et al (2010)](http://web.stanford.edu/~hastie/Papers/mazumder10a.pdf)
 * [Hastie et al (2014)](http://arxiv.org/abs/1410.2596)